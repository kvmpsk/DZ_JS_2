'use strict'
// let regExp = new regExp('выражение', 'флаги'); // «Длинный» синтаксис создания регулярного выражения.
// let regExp = /'выражение'/; // короткий синтаксис без флага
// let regExp = /'выражение'/gmi; // короткий синтаксис с флагами

// Флаги
// i - поиск без учета регистра
// g - С этим флагом поиск ищет все совпадения, без него – только первое.
// m - многострочный поиск
// s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n
// u - Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар
// y - Режим поиска на конкретной позиции в тексте

// let str = 'Язык JavaScript называется так из-за популярности языка Java';
//
// let regExp = new RegExp('java', 'ig');

// str.search
// возвращает индекс первого найденного вхождения
// -1 если вхождений не найдено.
// console.log(str.search(regExp));

// str.match
// null - если вхождений не найдено
// возвращает массив-объект с информацией о найденном вхождении
// c флагом g, всегда возвращается только массив с найденными вхождениями
// console.log(str.match(/red/ig));

// str.replace заменяет совпадения с regexp в строке str на replacement (все, если есть флаг g, иначе только первое).
//В строке замены replacement мы можем использовать специальные комбинации символов для вставки фрагментов совпадения
// Спецсимволы	Действие в строке замены
// $&	вставляет всё найденное совпадение
// $`	вставляет часть строки до совпадения
// $'	вставляет часть строки после совпадения
// $n	если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения, больше об этом в главе Скобочные группы
// $<name>	вставляет содержимое скобочной группы с именем name, также изучим в главе Скобочные группы
// $$	вставляет символ "$"

// console.log('+7 (000)000-00-00'.replace('-', ':'));
// console.log('+7 (000)000-00-00'.replace(/-/g, ':'));


//regexp.test Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false.

// let str = "Я ЛюБлЮ JavaScript";
// let regexp = /люблю/i;
// console.log(regexp.test(str)); // true

// let name = 'Snow, John';
// console.log(name.replace(/([a-z]+), ([a-z]+)/i, 'Было: $&;\nСтало: $2 $1'));

// Классы
// \d - [0123456789] - [0-9]    («d» от английского «digit» означает «цифра»)
// \D - [^0123456789] - [^0-9]  Не цифра: любой символ, кроме \d, например буква.
// \w - [a-z0-9_]               («w»: от английского «word» – «слово»)
// \W - [^a-z0-9_]              Любой символ, кроме \w, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу.
// \s - space, tab, \n          («s»: от английского «space» – «пробел»)
// \S                           Не пробел: любой символ, кроме \s, например буква.
// \b - граница слова           не работает для алфавитов, не основанных на латинице
// \B
// . - любой символ, если с флагом регулярного выражения s, в противном случае любой символ, кроме перевода строки \n


// [а-яА-ЯёЁ]

// квантификаторы
// {m} - строго m раз
// {m,n} - от m до n раз
// {m,} - от m до бесконечности
// {,n} - от 0 до n раз

// сокращения
// + - {1,}
// * - {0,}
// ? - {0,1}

// Якоря: начало строки ^ и конец $
// Оба якоря вместе ^...$ часто используются для проверки, совпадает ли строка с шаблоном полностью.

// Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: \..
// Это называется «экранирование символа».
// Пример
// alert( "Глава 5.1".match(/\d\.\d/) ); // 5.1 (совпадение!)
// alert( "Глава 511".match(/\d\.\d/) ); // null ("\." - ищет обычную точку)

// Символ косой черты '/', так называемый «слэш», не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: /...шаблон.../, поэтому мы должны экранировать его.
// Вот как выглядит поиск самой косой черты '/':
// alert( "/".match(/\//) ); // '/'

// Для поиска специальных символов [ \ ^ $ . | ? * + ( ), нам нужно добавить перед ними \ («экранировать их»).
// Нам также нужно экранировать /, если мы используем /.../ (но не new RegExp).
// При передаче строки в new RegExp нужно удваивать обратную косую черту: \\ для экранирования специальных символов, потому что строковые кавычки «съедят» одну черту.


// console.log('+7-(000) 000:00-00'.replace(/\D/g, '')); // => 70000000000
// console.log('+7-(000) 000:00-00'.match(/\d+/g).join('')); // => 70000000000

// console.log('color colour'.match(/colou?r/g));
// console.log('color colour colotr coloutr'.match(/colo[ut]?r/g));

// console.log('Язык JavaScript это не Java вам =)'.match(/\bjava\b/i));

// console.log('JavaScript это не Java'.match(/^java/i));
// console.log('JavaScript это не Java'.match(/java$/i));
// console.log('JavaScript это не Java'.match(/^java$/i));

// console.log('Chapter 7.2'.match(/\d\.\d/g));

  // Внимание, пробелы!
  // Обычно мы уделяем мало внимания пробелам. Для нас строки 1-5 и 1 - 5 практически идентичны.
  //
  // Но если регулярное выражение не учитывает пробелы, оно может не сработать.
  //
  // Давайте попробуем найти цифры, разделённые дефисом:

// alert( "1 - 5".match(/\d-\d/) ); // null, нет совпадения!

// alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, теперь работает
// // или можно использовать класс \s:
// alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, тоже работает

// Домашнее задание

console.log('Hi \'all\' hi \'you\'.'.replace(/'/g, '"'));

console.log('Hi \'all\' hi \'you\', don\'t you?' .replace(/\B'|'\B/g, '"'));
